/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

use crate::header::CTStackVal;
use crate::header::CTStackVal::*;
use crate::header::Capability;
use crate::header::Capability::*;
use crate::header::Error;
use crate::header::Error::*;
use crate::header::Id;
use crate::header::Kind::*;
use crate::header::KindContext;
use crate::header::KindContextEntry::*;
use crate::header::Label;
use crate::header::Pos;
use crate::header::Region;
use crate::header::Region::*;
use crate::header::Type;
use crate::header::Type::*;
use crate::header::UnverifiedOpcode;
use crate::header::UnverifiedOpcode::*;
use crate::header::UnverifiedStmt;
use crate::header::VerifiedOpcode;
use crate::header::VerifiedStmt;
use crate::header::VerifiedStmt::*;
use std::collections::HashMap;
use std::collections::VecDeque;

/// The type of the stack; a sequence of the types of things on the stack.
pub type StackType = VecDeque<Type>;
/// The type of the compile-time stack, a stack of compile-time values.
pub type CTStackType = Vec<CTStackVal>;
/// The type of the constraints produced by the first pass of the verifier.
/// Note that this is not like Hindley-Milner or anything like that:
/// the first pass gets the types of all the functions without using any constraints.
/// The constraints are only checked to make sure the functions are well-typed, not to derive any types.
pub type Constraints = HashMap<Label, (Pos, Vec<Capability>, StackType, CTStackType)>;

pub fn go(unverified_stmts: Vec<UnverifiedStmt>) -> Result<Vec<VerifiedStmt>, Error> {
    let mut verified_stmts: Vec<VerifiedStmt> = vec![];
    let stmts2: Vec<(VerifiedStmt, Constraints)> = unverified_stmts
        .iter()
        .map(|stmt| first_pass(stmt))
        .collect::<Result<Vec<_>, Error>>()?;
    let mut constraints: Constraints = HashMap::new();
    for pair in stmts2 {
        let (stmt, c) = pair;
        constraints.extend(c);
        verified_stmts.push(stmt);
    }
    let () = second_pass(
        constraints,
        &verified_stmts
            .iter()
            .map(|Func(l, t, _)| (l.to_owned(), t.to_owned()))
            .collect(),
    )?;
    Ok(verified_stmts)
}

/// The first pass of the verifier.
pub fn first_pass(func: &UnverifiedStmt) -> Result<(VerifiedStmt, Constraints), Error> {
    let UnverifiedStmt::Func(label, ops) = func;
    let mut ops_iter = ops.iter();

    // The stacks used for this pass algorithm.
    let mut compile_time_stack: CTStackType = vec![];
    let mut stack_type: StackType = VecDeque::from([]);
    let mut exist_stack: Vec<Id> = vec![];

    // The types the function expects the top of the stack to have.
    let mut arg_types: Vec<Type> = vec![];
    // The capabilities the function expects the caller to have.
    let mut cap_coeffect: Vec<Capability> = vec![];

    // The constraints generated by this first pass.
    let mut constraints: Constraints = HashMap::new();
    // The verified bytecode produced by this first pass.
    let mut verified_ops: Vec<VerifiedOpcode> = vec![];

    // The list of region variables the function is quantified (polymorphic) over.
    let mut rgn_vars: Vec<Id> = vec![];
    // The list of capability variables the function is quantified (polymorphic) over, and their bounds.
    let mut capability_bounds: HashMap<Id, Vec<Capability>> = HashMap::new();
    // The list of type variables the function is quantified (polymorphic) over.
    let mut type_vars: Vec<Id> = vec![];

    // The kind context (\Delta in the Capability Calculus paper) the function has.
    // This is generated alongside the above three variables, capturing the same information in a different form
    // that's useful for different purposes.
    let mut kind_context: KindContext = vec![];

    // The generator of fresh identifiers.
    let mut fresh_id: u32 = 0;
    // The variable tracking the current byte position, for nice error reporting.
    let mut pos = *label;

    loop {
        match ops_iter.next() {
            None => break,
            Some(op) => match op {
                ReqOp => match compile_time_stack.pop() {
                    None => return Err(TypeErrorEmptyCTStack(pos, *op)),
                    Some(TypeCTStackVal(t)) => {
                        arg_types.push(t.clone());
                        stack_type.push_front(t);
                    }
                    Some(CapCTStackVal(caps)) => cap_coeffect.extend(caps),
                    Some(ctval) => {
                        return Err(KindErrorReq(pos, ctval));
                    }
                },
                RegionOp => {
                    let id = Id(*label, fresh_id);
                    let r = VarRgn(id);
                    compile_time_stack.push(RegionCTStackVal(r));
                    rgn_vars.push(id);
                    kind_context.push(RegionKindContextEntry(id));
                    fresh_id += 1;
                }
                HeapOp => compile_time_stack.push(RegionCTStackVal(Region::HeapRgn)),
                CapOp => {
                    let id = Id(*label, fresh_id);
                    let var = VarCap(id);
                    let cap = vec![var];
                    capability_bounds.insert(id, vec![]);
                    kind_context.push(CapabilityKindContextEntry(id, vec![]));
                    compile_time_stack.push(CapCTStackVal(cap));
                    fresh_id += 1;
                }
                CapLEOp => {
                    let mb_bound = compile_time_stack.pop();
                    match mb_bound {
                        Some(CapCTStackVal(bound)) => {
                            let id = Id(*label, fresh_id);
                            let var = VarCap(id);
                            compile_time_stack.push(CapCTStackVal(vec![var]));
                            capability_bounds.insert(id, bound.clone());
                            kind_context.push(CapabilityKindContextEntry(id, bound));
                            fresh_id += 1;
                        }
                        Some(ctval) => return Err(KindError(pos, *op, CapabilityKind, ctval)),
                        None => return Err(TypeErrorEmptyCTStack(pos, *op)),
                    }
                }
                UniqueOp => {
                    let mb_rgn = compile_time_stack.pop();
                    match mb_rgn {
                        Some(RegionCTStackVal(r)) => {
                            compile_time_stack.push(CapCTStackVal(vec![UniqueCap(r)]))
                        }
                        Some(ctval) => return Err(KindError(pos, *op, RegionKind, ctval)),
                        None => return Err(TypeErrorEmptyCTStack(pos, *op)),
                    }
                }
                RWOp => {
                    let mb_rgn = compile_time_stack.pop();
                    match mb_rgn {
                        Some(RegionCTStackVal(r)) => {
                            compile_time_stack.push(CapCTStackVal(vec![ReadWriteCap(r)]))
                        }
                        Some(ctval) => return Err(KindError(pos, *op, RegionKind, ctval)),
                        None => return Err(TypeErrorEmptyCTStack(pos, *op)),
                    }
                }
                BothOp => {
                    let mb_cap1 = compile_time_stack.pop();
                    match mb_cap1 {
                        Some(CapCTStackVal(cap1)) => {
                            let mb_cap2 = compile_time_stack.pop();
                            match mb_cap2 {
                                Some(CapCTStackVal(cap2)) => compile_time_stack
                                    .push(CapCTStackVal([&cap1[..], &cap2[..]].concat())),
                                Some(ctval) => {
                                    return Err(KindError(pos, *op, CapabilityKind, ctval))
                                }
                                None => return Err(TypeErrorEmptyCTStack(pos, *op)),
                            }
                        }
                        Some(ctval) => return Err(KindError(pos, *op, CapabilityKind, ctval)),
                        None => return Err(TypeErrorEmptyCTStack(pos, *op)),
                    }
                }
                HandleOp => {
                    let mb_rgn = compile_time_stack.pop();
                    match mb_rgn {
                        Some(RegionCTStackVal(r)) => {
                            compile_time_stack.push(TypeCTStackVal(HandleType(r)))
                        }
                        Some(ctval) => return Err(KindError(pos, *op, RegionKind, ctval)),
                        None => return Err(TypeErrorEmptyCTStack(pos, *op)),
                    }
                }
                I32Op => compile_time_stack.push(TypeCTStackVal(I32Type)),
                EndFunctionOp => panic!("op-end found during verification"),
                MutOp => {
                    let mb_type = compile_time_stack.pop();
                    match mb_type {
                        Some(TypeCTStackVal(t)) => {
                            compile_time_stack.push(TypeCTStackVal(MutableType(Box::new(t))))
                        }
                        Some(ctval) => return Err(KindError(pos, *op, TypeKind, ctval)),
                        None => return Err(TypeErrorEmptyCTStack(pos, *op)),
                    }
                }
                TupleOp(size) => {
                    let mut component_types = vec![];
                    for _ in 0..*size {
                        let mb_type = compile_time_stack.pop();
                        match mb_type {
                            Some(TypeCTStackVal(t)) => component_types.push(t),
                            Some(ctval) => return Err(KindError(pos, *op, TypeKind, ctval)),
                            None => return Err(TypeErrorEmptyCTStack(pos, *op)),
                        }
                    }
                    let mb_rgn = compile_time_stack.pop();
                    match mb_rgn {
                        Some(RegionCTStackVal(r)) => {
                            compile_time_stack.push(TypeCTStackVal(TupleType(component_types, r)))
                        }
                        Some(ctval) => return Err(KindError(pos, *op, RegionKind, ctval)),
                        None => return Err(TypeErrorEmptyCTStack(pos, *op)),
                    }
                }
                ArrOp => {
                    let mb_type = compile_time_stack.pop();
                    match mb_type {
                        Some(TypeCTStackVal(t)) => {
                            compile_time_stack.push(TypeCTStackVal(ArrayType(Box::new(t))))
                        }
                        Some(ctval) => return Err(KindError(pos, *op, TypeKind, ctval)),
                        None => return Err(TypeErrorEmptyCTStack(pos, *op)),
                    }
                }
                AllOp => {
                    let id = Id(*label, fresh_id);
                    let t = VarType(id);
                    compile_time_stack.push(TypeCTStackVal(t));
                    type_vars.push(id);
                    kind_context.push(TypeKindContextEntry(id));
                    fresh_id += 1
                }
                SomeOp => {
                    let id = Id(*label, fresh_id);
                    compile_time_stack.push(TypeCTStackVal(VarType(id)));
                    exist_stack.push(id);
                    fresh_id += 1;
                }
                EmosOp => {
                    let mb_var = exist_stack.pop();
                    match mb_var {
                        None => return Err(TypeErrorEmptyExistStack(pos, *op)),
                        Some(id) => {
                            let mb_type = compile_time_stack.pop();
                            match mb_type {
                                Some(TypeCTStackVal(t)) => compile_time_stack
                                    .push(TypeCTStackVal(ExistsType(id, Box::new(t)))),
                                Some(ctval) => return Err(KindError(pos, *op, TypeKind, ctval)),
                                None => return Err(TypeErrorEmptyCTStack(pos, *op)),
                            }
                        }
                    }
                }
                FuncOp(num_args) => {
                    let mut arg_ts = vec![];
                    for _ in 0..*num_args {
                        let mb_type = compile_time_stack.pop();
                        match mb_type {
                            Some(TypeCTStackVal(t)) => arg_ts.push(t),
                            Some(ctval) => return Err(KindError(pos, *op, TypeKind, ctval)),
                            None => return Err(TypeErrorEmptyCTStack(pos, *op)),
                        }
                    }
                    let mb_cap = compile_time_stack.pop();
                    match mb_cap {
                        Some(CapCTStackVal(c)) => {
                            compile_time_stack.push(TypeCTStackVal(FuncType(vec![], c, arg_ts)))
                        }
                        Some(ctval) => return Err(KindError(pos, *op, CapabilityKind, ctval)),
                        None => return Err(TypeErrorEmptyCTStack(pos, *op)),
                    }
                }
                CTGetOp(i) => {
                    let ct_stack_len = compile_time_stack.len();
                    if ct_stack_len == 0 {
                        return Err(TypeErrorEmptyCTStack(pos, *op));
                    }
                    let i2 = usize::from(*i);
                    if ct_stack_len - 1 < i2 {
                        return Err(TypeErrorParamOutOfRange(pos, *op));
                    }
                    compile_time_stack.push(
                        compile_time_stack
                            .get(ct_stack_len - i2 - 1)
                            .unwrap()
                            .clone(),
                    );
                }
                CTPopOp => {
                    compile_time_stack.pop();
                }
                UnpackOp => {
                    let mb_existential = stack_type.pop_back();
                    match mb_existential {
                        Some(t) => match t {
                            ExistsType(_id, t) => {
                                stack_type.push_back(*t) // simply remove the quantifier, unbinding its variable
                            }
                            _ => return Err(TypeErrorExistentialExpected(pos, t)),
                        },
                        None => return Err(TypeErrorEmptyStack(pos, *op)),
                    }
                }
                UnverifiedOpcode::GetOp(i) => {
                    let stack_len = stack_type.len();
                    if stack_len == 0 {
                        return Err(TypeErrorEmptyStack(pos, *op));
                    }
                    let i2 = usize::from(*i);
                    if stack_len - 1 < i2 {
                        return Err(TypeErrorParamOutOfRange(pos, *op));
                    }
                    stack_type.push_back(stack_type.get(stack_len - 1 - i2).unwrap().clone());
                    verified_ops.push(VerifiedOpcode::GetOp(*i))
                }
                UnverifiedOpcode::InitOp(i) => {
                    let mb_val = stack_type.pop_back();
                    let mb_tpl = stack_type.pop_back();
                    match mb_tpl {
                        Some(tpl) => match tpl.clone() {
                            TupleType(component_types, r) => match component_types
                                .get(usize::from(*i))
                            {
                                None => return Err(TypeErrorParamOutOfRange(pos, *op)),
                                Some(formal) => match mb_val {
                                    None => return Err(TypeErrorEmptyStack(pos, *op)),
                                    Some(actual) => {
                                        if cap_coeffect
                                            .iter()
                                            .all(|c| !capable_read_write(&r, c, &capability_bounds))
                                        {
                                            return Err(CapabilityError(
                                                pos,
                                                *op,
                                                vec![ReadWriteCap(r)],
                                                cap_coeffect,
                                            ));
                                        }
                                        if formal == &actual {
                                            stack_type.push_back(tpl)
                                        } else {
                                            return Err(TypeErrorInit(pos, formal.clone(), actual));
                                        }
                                    }
                                },
                            },
                            _ => return Err(TypeErrorTupleExpected(pos, *op, tpl)),
                        },
                        None => return Err(TypeErrorEmptyStack(pos, *op)),
                    }
                    verified_ops.push(VerifiedOpcode::InitOp(*i))
                }
                UnverifiedOpcode::MallocOp => {
                    let mb_type = compile_time_stack.pop();
                    let t = match mb_type {
                        Some(TypeCTStackVal(t)) => t,
                        Some(ctval) => return Err(KindError(pos, *op, TypeKind, ctval)),
                        None => return Err(TypeErrorEmptyCTStack(pos, *op)),
                    };
                    let mb_rgn_handle = stack_type.pop_back();
                    match mb_rgn_handle {
                        Some(HandleType(r)) => {
                            if cap_coeffect
                                .iter()
                                .all(|c| !capable_read_write(&r, c, &capability_bounds))
                            {
                                return Err(CapabilityError(
                                    pos,
                                    *op,
                                    vec![ReadWriteCap(r)],
                                    cap_coeffect,
                                ));
                            }
                        }
                        Some(t) => {
                            return Err(TypeErrorRegionHandleExpected(pos, *op, t));
                        }
                        None => return Err(TypeErrorEmptyStack(pos, *op)),
                    }
                    stack_type.push_back(t);
                    verified_ops.push(VerifiedOpcode::MallocOp(4)) // TODO: use actual size in bytes of t (sized data with kinds-are-calling-conventions polymorphism)
                }
                UnverifiedOpcode::ProjOp(i) => {
                    let mb_tpl = stack_type.pop_back();
                    match mb_tpl {
                        Some(tpl) => match tpl {
                            TupleType(component_types, r) => {
                                match component_types.get(usize::from(*i)) {
                                    None => return Err(TypeErrorParamOutOfRange(pos, *op)),
                                    Some(t) => {
                                        if cap_coeffect
                                            .iter()
                                            .all(|c| !capable_read_write(&r, c, &capability_bounds))
                                        {
                                            return Err(CapabilityError(
                                                pos,
                                                *op,
                                                vec![ReadWriteCap(r)],
                                                cap_coeffect,
                                            ));
                                        }
                                        stack_type.push_back(t.clone());
                                    }
                                }
                            }
                            _ => return Err(TypeErrorTupleExpected(pos, *op, tpl)),
                        },
                        None => return Err(TypeErrorEmptyStack(pos, *op)),
                    }
                    verified_ops.push(VerifiedOpcode::ProjOp(*i))
                }
                UnverifiedOpcode::CallOp => {
                    let mb_type = stack_type.pop_back();
                    match mb_type {
                        Some(t) => match t {
                            GuessType(label) => {
                                constraints.insert(
                                    label,
                                    (
                                        pos,
                                        cap_coeffect.to_owned(),
                                        stack_type.to_owned(),
                                        compile_time_stack.to_owned(),
                                    ),
                                );
                            }
                            FuncType(quantified, caps_needed, args) => {
                                let () = verify_call(
                                    quantified,
                                    pos,
                                    &args,
                                    stack_type.to_owned(),
                                    compile_time_stack.to_owned(),
                                    &cap_coeffect,
                                    caps_needed,
                                )?;
                            }
                            _ => return Err(TypeErrorFunctionExpected(pos, *op, t)),
                        },
                        None => return Err(TypeErrorEmptyStack(pos, *op)),
                    }
                    verified_ops.push(VerifiedOpcode::CallOp)
                }
                PrintOp => {
                    let mb_type = stack_type.pop_back();
                    match mb_type {
                        Some(I32Type) => verified_ops.push(VerifiedOpcode::PrintOp),
                        Some(t) => return Err(TypeError(pos, *op, I32Type, t)),
                        None => return Err(TypeErrorEmptyStack(pos, *op)),
                    }
                }
                LitOp(lit) => {
                    stack_type.push_back(I32Type);
                    verified_ops.push(VerifiedOpcode::LitOp(*lit))
                }
                GlobalFuncOp(label) => {
                    stack_type.push_back(GuessType(*label));
                    verified_ops.push(VerifiedOpcode::GlobalFuncOp(*label))
                }
            },
        }
        pos += 1;
    }
    if exist_stack.len() > 0 {
        return Err(TypeErrorNonEmptyExistStack(*label));
    }
    let t = FuncType(kind_context, cap_coeffect, arg_types);
    Ok((VerifiedStmt::Func(*label, t, verified_ops), constraints))
}

pub fn second_pass(constraints: Constraints, types: &HashMap<Label, Type>) -> Result<(), Error> {
    for (label, (pos, caps_present, stack_type, compile_time_stack)) in constraints {
        let FuncType(kind_context, caps_needed, arg_ts_needed) = types.get(&label).unwrap().clone()
        else {
            panic!()
        };
        let () = verify_call(
            kind_context,
            pos,
            &arg_ts_needed,
            stack_type,
            compile_time_stack,
            &caps_present,
            caps_needed,
        )?;
    }
    Ok(())
}

/// Produce, from some function type information and the top of the compile-time stack,
/// some hashmaps describing substitutions that must be made in the rest of the type of the function.
pub fn get_substitutions(
    pos: Pos,
    ct_args: Vec<CTStackVal>,
    quantified: KindContext,
    cap_bounds: &HashMap<Id, Vec<Capability>>,
) -> Result<
    (
        HashMap<Id, Region>,
        HashMap<Id, Vec<Capability>>,
        HashMap<Id, Type>,
    ),
    Error,
> {
    let mut ct_args = ct_args.iter();
    let mut cap_assignments: HashMap<Id, Vec<Capability>> = HashMap::new();
    let mut rgn_assignments: HashMap<Id, Region> = HashMap::new();
    let mut type_assignments: HashMap<Id, Type> = HashMap::new();
    if ct_args.len() != quantified.len() {
        panic!("instantiate given vectors of unequal length; this should have been handled by the caller")
    }

    for entry in quantified {
        let actual = ct_args.next().unwrap();
        match entry {
            CapabilityKindContextEntry(id, bound) => match actual {
                CapCTStackVal(c) => {
                    // check that the instantiated capability is more restrictive than the formal one, or equally restrictive
                    if caps_satisfy_caps(c.to_vec(), &substitute_c(&bound, &rgn_assignments, &cap_assignments), &cap_bounds) {
                        cap_assignments.insert(id, c.to_vec());
                    } else {
                        return Err(Error::CapabilityErrorBadInstantiation(
                            pos,
                            substitute_c(&bound, &rgn_assignments, &cap_assignments),
                            c.to_vec(),
                        ));
                    }
                }
                ctval => {
                    return Err(Error::KindErrorBadInstantiation(
                        pos,
                        CapabilityKind,
                        ctval.clone(),
                    ))
                }
            },
            RegionKindContextEntry(id) => match actual {
                CTStackVal::RegionCTStackVal(r) => {
                    rgn_assignments.insert(id, *r);
                }
                ctval => {
                    return Err(Error::KindErrorBadInstantiation(
                        pos,
                        RegionKind,
                        ctval.clone(),
                    ))
                }
            },
            TypeKindContextEntry(id) => match actual {
                CTStackVal::TypeCTStackVal(t) => {
                    type_assignments.insert(id, t.clone());
                }
                ctval => {
                    return Err(Error::KindErrorBadInstantiation(
                        pos,
                        TypeKind,
                        ctval.clone(),
                    ))
                } // kind error- instantiated type var with a nontype
            },
        }
    }
    // then check that the parameter types match the top of the stack type
    Ok((rgn_assignments, cap_assignments, type_assignments))
}

/// Check if one capability is a subcapability of another.
// fn cap_subtype(
//     cap1: &Capability,
//     cap2: &Capability,
//     cap_bounds: &HashMap<Id, Vec<Capability>>,
// ) -> bool {
//     match (cap1, cap2) {
//         (UniqueCap(r1), UniqueCap(r2)) if r1 == r2 => true,
//         (UniqueCap(r1), ReadWriteCap(r2)) if r1 == r2 => true,
//         (ReadWriteCap(r1), ReadWriteCap(r2)) if r1 == r2 => true,
//         (ReadWriteCap(_), UniqueCap(_)) => false,
//         (VarCap(id1), VarCap(id2)) if id1 == id2 => true,
//         (VarCap(id), cap2) => {
//             let bound = cap_bounds.get(id).unwrap();
//             caps_satisfy_cap(bound, cap2, cap_bounds)
//         }
//         _ => false,
//     }
// }

// /// Check if a capability set is sufficient to satisfy a given capability.
// fn caps_satisfy_cap(
//     caps: &[Capability],
//     cap: &Capability,
//     cap_bounds: &HashMap<Id, Vec<Capability>>,
// ) -> bool {
//     caps.iter().any(|c_p| cap_subtype(c_p, cap, cap_bounds))
// }

/// Check if a capability set is sufficient to satisfy another capability set.
// This function is subtle because capabilities are relevant; that is, they cannot be forgotten.
// In addition, some capabilities can be duplicated.
// {c, 1r} doesn't satisfy {c}, so the program must free r first
// {c, +r} doesn't satisfy {c}, so the program must be careful about duplicating +r
// {c} doesn't satisfy {c, +r} even if c is bounded by +r, because it could be instantiated with 1r so it must not be duplicated.
// {1r, 1r} satisfies {1r, 1r}, but you shouldn't be able to make a {1r, 1r} capability; only dead codepaths have them.
// So {1r} doesn't satisfy {1r, 1r}.
// {+r} *does* satisfy {+r, +r}, because {+r} is duplicable; that is, {+r} *equals* {+r, +r}.
// The theoretical characterization of what's going on is that capabilities have no contraction, and some don't even have weakening.
// No contraction means that if we have {x, y} and are trying to coerce it to {z}, we must use both x and y. We can't drop them.
// No weakening (for uniques) means that if we have {x} and we're trying to coerce it to {y, z}, we can only use x once.
// This function is ultimately an attempt to coerce caps1 into caps2.
// One approach is to remove capabilities from caps1 as we use them.
// For each capability in caps2, remove that capability from caps1.
// If the capability we removed is readwrite, also add it to a used_readwrites capability set.
// If there isn't any and the capability we're looking for is readwrite, see if there's any in used_readwrites.
// If there isn't any and there isn't any in used_readwrites, fail
// If we make it to the end, fail if caps1 is nonempty. That would mean some weren't used.
// The question is, how do we make this support using 1r for +r?
// The answer is, if we have 1r, then we know that any +r in the same capability set is referring to a different r.
// So it will never be the case that a +r can be satisfied either by 1r or +r,
// so if we need to satisfy +r and 1r works, we would fail immediately if we hesitated from using the 1r to satisfy the +r.
pub fn caps_satisfy_caps(
    mut caps1: Vec<Capability>,
    caps2: &[Capability],
    cap_bounds: &HashMap<Id, Vec<Capability>>,
) -> bool {
    let mut used_readwrites = vec![];
    for needed_cap in caps2 {
        match needed_cap {
            Capability::UniqueCap(r) => {
                let mb_pos = caps1.iter().position(|present_cap| match present_cap {
                    Capability::UniqueCap(r2) if r == r2 => true,
                    Capability::VarCap(id) => {
                        let bound = cap_bounds.get(id).unwrap();
                        caps_satisfy_caps(bound.to_vec(), &[Capability::UniqueCap(*r)], cap_bounds)
                    }
                    _ => false,
                });
                match mb_pos {
                    Some(pos) => {
                        caps1.remove(pos);
                    }
                    None => return false,
                }
            }
            Capability::ReadWriteCap(r) => {
                let mb_pos = caps1.iter().position(|present_cap| match present_cap {
                    Capability::UniqueCap(r2) if r == r2 => true,
                    Capability::ReadWriteCap(r2) if r == r2 => {
                        used_readwrites.push(r2.clone());
                        return true;
                    }
                    Capability::VarCap(id) => {
                        let bound = cap_bounds.get(id).unwrap();
                        caps_satisfy_caps(
                            bound.to_vec(),
                            &[Capability::ReadWriteCap(*r)],
                            cap_bounds,
                        )
                    }
                    _ => false,
                });
                match mb_pos {
                    Some(pos) => {
                        caps1.remove(pos);
                    }
                    None => {
                        if !used_readwrites.iter().any(|r2| r == r2) {
                            return false;
                        }
                    }
                }
            }
            Capability::VarCap(id) => {
                let mb_pos = caps1.iter().position(|present_cap| match present_cap {
                    Capability::VarCap(id2) if id == id2 => true,
                    _ => false,
                });
                match mb_pos {
                    Some(pos) => {
                        caps1.remove(pos);
                    }
                    None => return false,
                }
            }
        }
    }
    if caps1.len() > 0 {
        return false;
    }
    return true;
}

/// Perform some variable substitutions within a type.
/// This does not modify the original.
pub fn substitute_t(
    typ: &Type,
    tsubs: &HashMap<Id, Type>,
    rsubs: &HashMap<Id, Region>,
    csubs: &HashMap<Id, Vec<Capability>>,
) -> Type {
    match typ {
        Type::I32Type => Type::I32Type,
        Type::HandleType(r) => Type::HandleType(substitute_r(r, rsubs)),
        Type::MutableType(t) => Type::MutableType(Box::new(substitute_t(t, tsubs, rsubs, csubs))),
        Type::TupleType(ts, r) => Type::TupleType(
            ts.iter()
                .map(|t| substitute_t(t, tsubs, rsubs, csubs))
                .collect(),
            substitute_r(r, rsubs),
        ),
        Type::ArrayType(t) => Type::ArrayType(Box::new(substitute_t(t, tsubs, rsubs, csubs))),
        Type::VarType(id) => match tsubs.get(id) {
            Some(new) => new.clone(),
            None => Type::VarType(*id),
        },
        Type::FuncType(kind_context, caps, args) => Type::FuncType(
            kind_context.clone(),
            substitute_c(caps, rsubs, csubs),
            args.iter()
                .map(|t| substitute_t(t, tsubs, rsubs, csubs))
                .collect(),
        ),
        Type::ExistsType(x, t) => {
            Type::ExistsType(*x, Box::new(substitute_t(t, tsubs, rsubs, csubs)))
        }
        Type::GuessType(label) => Type::GuessType(*label),
    }
}

/// Perform some variable substitutions in a compile-time region value.
/// This does not modify the original
pub fn substitute_r(rgn: &Region, rsubs: &HashMap<Id, Region>) -> Region {
    match rgn {
        Region::HeapRgn => Region::HeapRgn,
        Region::VarRgn(id) => match rsubs.get(id) {
            Some(new) => new.clone(),
            None => Region::VarRgn(*id),
        },
    }
}

/// Perform some variable substitutions in a capability set.
/// This does not modify the original.
pub fn substitute_c(
    caps: &Vec<Capability>,
    rsubs: &HashMap<Id, Region>,
    csubs: &HashMap<Id, Vec<Capability>>,
) -> Vec<Capability> {
    let mut out = vec![];
    for cap in caps {
        match cap {
            Capability::UniqueCap(r) => out.push(Capability::UniqueCap(substitute_r(r, rsubs))),
            Capability::ReadWriteCap(r) => {
                out.push(Capability::ReadWriteCap(substitute_r(r, rsubs)))
            }
            Capability::VarCap(id) => match csubs.get(id) {
                Some(new) => out.extend(new.clone()),
                None => out.push(Capability::VarCap(*id)),
            },
        }
    }
    return out;
}

/// Check if two types are equal, for typechecking purposes.
pub fn type_eq(type1: &Type, type2: &Type, cap_bounds: &HashMap<Id, Vec<Capability>>) -> bool {
    match (type1, type2) {
        (Type::I32Type, Type::I32Type) => true,
        (Type::HandleType(r1), Type::HandleType(r2)) => r1 == r2,
        (Type::MutableType(t1), Type::MutableType(t2)) => type_eq(t1, t2, cap_bounds),
        (Type::TupleType(ts1, r1), Type::TupleType(ts2, r2)) => {
            r1 == r2 && ts1.len() == ts2.len() && {
                let mut ts2 = ts2.iter();
                for t1 in ts1 {
                    let t2 = ts2.next().unwrap();
                    if !type_eq(t1, t2, cap_bounds) {
                        return false;
                    }
                }
                return true;
            }
        }
        (Type::ArrayType(t1), Type::ArrayType(t2)) => type_eq(t1, t2, cap_bounds),
        (Type::VarType(id1), Type::VarType(id2)) => id1 == id2,
        (Type::FuncType(kind_context1, caps1, ts1), Type::FuncType(kind_context2, caps2, ts2)) => {
            if kind_context1.len() != kind_context2.len() {
                return false;
            }
            let mut kind_context2_iter = kind_context2.iter();
            let mut cap_assignments = HashMap::new();
            let mut rgn_assignments = HashMap::new();
            let mut type_assignments = HashMap::new();
            for entry1 in kind_context1 {
                let entry2 = kind_context2_iter.next().unwrap();
                match (entry1, entry2) {
                    (
                        CapabilityKindContextEntry(id1, bound1),
                        CapabilityKindContextEntry(id2, bound2),
                    ) => {
                        if !caps_satisfy_caps(bound1.to_vec(), bound2, cap_bounds)
                            || !caps_satisfy_caps(bound2.to_vec(), bound1, cap_bounds)
                        {
                            return false;
                        }
                        cap_assignments.insert(*id2, vec![Capability::VarCap(*id1)]);
                    }
                    (RegionKindContextEntry(id1), RegionKindContextEntry(id2)) => {
                        rgn_assignments.insert(*id2, Region::VarRgn(*id1));
                    }
                    (TypeKindContextEntry(id1), TypeKindContextEntry(id2)) => {
                        type_assignments.insert(*id2, Type::VarType(*id1));
                    }
                    _ => return false,
                }
            }
            let types_match = ts1.iter().zip(ts2.iter()).all(|(t1, t2)| {
                type_eq(
                    t1,
                    &substitute_t(t2, &type_assignments, &rgn_assignments, &cap_assignments),
                    cap_bounds,
                )
            });
            if !types_match {
                return false;
            }
            if !caps_satisfy_caps(caps1.to_vec(), caps2, cap_bounds)
                || !caps_satisfy_caps(caps2.to_vec(), caps1, cap_bounds)
            {
                return false;
            }
            return true;
        }
        (Type::ExistsType(id1, t1), Type::ExistsType(id2, t2)) => {
            let mut sub = HashMap::new();
            sub.insert(*id2, Type::VarType(*id1));
            let t2_subbed = substitute_t(t2, &sub, &HashMap::new(), &HashMap::new());
            type_eq(t1, &t2_subbed, cap_bounds)
        }
        (Type::GuessType(label1), Type::GuessType(label2)) => label1 == label2,
        (_, _) => false,
    }
}

/// Check if a capability is able to read and write in the given region.
pub fn capable_read_write(
    rgn: &Region,
    cap: &Capability,
    cap_bounds: &HashMap<Id, Vec<Capability>>,
) -> bool {
    match cap {
        Capability::UniqueCap(rgn2) | Capability::ReadWriteCap(rgn2) if *rgn == *rgn2 => true,
        Capability::VarCap(id) => {
            let caps = cap_bounds.get(id).unwrap();
            caps.iter().any(|c| capable_read_write(rgn, c, cap_bounds))
        }
        _ => false,
    }
}

pub fn verify_call(
    quantified: KindContext,
    pos: Pos,
    args: &Vec<Type>,
    mut stack_type: StackType,
    mut compile_time_stack: CTStackType,
    cap_coeffect: &Vec<Capability>,
    caps_needed: Vec<Capability>,
) -> Result<(), Error> {
    let mut instantiation = vec![];
    for _ in 0..quantified.len() {
        match compile_time_stack.pop() {
            Some(ctval) => instantiation.push(ctval),
            None => {
                return Err(TypeErrorNotEnoughCompileTimeArgs(
                    pos,
                    quantified.len(),
                    instantiation.len(),
                ))
            }
        }
    }
    let caps_present = &cap_coeffect;
    let arg_ts_needed = &args;
    let mut arg_ts_present = vec![];
    for _ in 0..arg_ts_needed.len() {
        match stack_type.pop_back() {
            Some(t) => arg_ts_present.push(t.clone()),
            None => {
                return Err(TypeErrorNotEnoughRuntimeArgs(
                    pos,
                    arg_ts_needed.len(),
                    arg_ts_present.len(),
                ));
            }
        }
    }
    let mut capability_bounds = HashMap::new();
    for entry in &quantified {
        if let CapabilityKindContextEntry(id, bound) = entry {
            capability_bounds.insert(id.to_owned(), bound.to_owned());
        }
    }
    let (rgn_assignments, cap_assignments, type_assignments) =
        get_substitutions(pos, instantiation, quantified, &capability_bounds)?;
    let caps_needed_subbed = substitute_c(&caps_needed, &rgn_assignments, &cap_assignments);
    let caps_are_sufficient = caps_satisfy_caps(
        caps_present.to_vec(),
        &caps_needed_subbed,
        &capability_bounds,
    );
    if !caps_are_sufficient {
        return Err(CapabilityError(
            pos,
            crate::header::UnverifiedOpcode::CallOp,
            caps_needed_subbed.clone(),
            caps_present.to_vec(),
        ));
    }
    let types_match = arg_ts_present
        .iter()
        .zip(arg_ts_needed.iter())
        .all(|(t1, t2)| {
            type_eq(
                t1,
                &substitute_t(t2, &type_assignments, &rgn_assignments, &cap_assignments),
                &capability_bounds,
            )
        });
    if !types_match {
        let arg_ts_needed = arg_ts_needed
            .iter()
            .map(|t| substitute_t(t, &type_assignments, &rgn_assignments, &cap_assignments))
            .collect::<Vec<_>>();
        return Err(TypeErrorCallArgTypesMismatch(
            pos,
            arg_ts_needed,
            arg_ts_present,
        ));
    }
    Ok(())
}
